package org.dancres.paxos.impl.faildet;

import org.dancres.paxos.FailureDetector;
import org.dancres.paxos.impl.*;
import org.dancres.paxos.impl.Transport.Packet;
import org.dancres.paxos.messages.Operations;
import org.dancres.paxos.messages.PaxosMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.InetSocketAddress;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * A simple failure detector driven by reception of {@link Heartbeat} messages generated by {@link Heartbeater}.
 * This implementation expects the transport to present all received messages to the detector via <code>processMessage</code>
 *
 * @todo Ultimately this detector could be further enhanced by using messages generated as part of standard Paxos interactions
 * to determine liveness.  The Heartbeater would then be modified to generate a message only if there had been an absence of
 * other messages sent by a node for a suitable period of time.
 */
public class FailureDetectorImpl implements MessageBasedFailureDetector {
    /**
     * @todo Fix up this majority to be more dynamic
     */
    private static final int DEFAULT_MAJORITY = 2;

    private final Random _random = new Random();
    private final ConcurrentMap<InetSocketAddress, MetaDataImpl> _lastHeartbeats =
            new ConcurrentHashMap<InetSocketAddress, MetaDataImpl>();
    private final ExecutorService _executor = Executors.newFixedThreadPool(1);
    private final Timer _tasks = new Timer();
    private final CopyOnWriteArraySet<MembershipImpl> _activeMemberships;
    private final long _maximumPeriodOfUnresponsiveness;
    private final AtomicBoolean _stopping = new AtomicBoolean(false);
    private final int _majority;

    private class MetaDataImpl implements FailureDetector.MetaData {
        final long _timestamp;
        final byte[] _metaData;

        MetaDataImpl(long aTimestamp, byte[] aMeta) {
            _timestamp = aTimestamp;
            _metaData = aMeta;
        }

        public byte[] getData() {
            return _metaData;
        }

        public long getTimestamp() {
            return _timestamp;
        }
    }

    private static final Logger _logger = LoggerFactory.getLogger(FailureDetectorImpl.class);

    /**
     * @param aMajority is the number of members in the cluster that must provide confirmation for an instance to
     *                  succeed.
     * @param anUnresponsivenessThreshold is the maximum period a node may "dark" before being declared failed.
     */
    public FailureDetectorImpl(int aMajority, long anUnresponsivenessThreshold) {
        _majority = aMajority;
        _maximumPeriodOfUnresponsiveness = anUnresponsivenessThreshold;
        _activeMemberships = new CopyOnWriteArraySet<MembershipImpl>();
        _tasks.schedule(new ScanImpl(), 0, (_maximumPeriodOfUnresponsiveness / 5));
    }

    /**
     * Assumes a three-node cluster in which a majority of 2 is sufficient for progress
     *
     * @param anUnresponsivenessThreshold
     */
    public FailureDetectorImpl(long anUnresponsivenessThreshold) {
        this(DEFAULT_MAJORITY, anUnresponsivenessThreshold);
    }

    public void stop() {
        _stopping.set(true);
        _tasks.cancel();
    	_executor.shutdownNow();
    }
    
    public Heartbeater newHeartbeater(Transport aTransport, byte[] aMetaData) {
        // We want at least three heartbeats within the unresponsiveness period
        //
        return new HeartbeaterImpl(aTransport, aMetaData, (_maximumPeriodOfUnresponsiveness / 3) - 100);
    }   

    private class ScanImpl extends TimerTask {
        public void run() {
            Iterator<InetSocketAddress> myProcesses = _lastHeartbeats.keySet().iterator();
            long myMinTime = System.currentTimeMillis() - _maximumPeriodOfUnresponsiveness;

            while (myProcesses.hasNext()) {
                InetSocketAddress myAddress = myProcesses.next();
                long myTimeout = _lastHeartbeats.get(myAddress)._timestamp;

                // No heartbeat since myMinTime means we assume dead
                //
                if (myTimeout < myMinTime) {
                    myProcesses.remove();
                    sendDead(myAddress);
                }
            }
        }
    }

    /**
     * Examine a received {@link PaxosMessage} and update liveness information as appropriate.
     */
    public void processMessage(Packet aPacket) throws Exception {
        PaxosMessage myMessage = aPacket.getMessage();

        if (myMessage.getType() == Operations.HEARTBEAT) {
            MetaDataImpl myLast;

            final Heartbeat myHeartbeat = (Heartbeat) myMessage;
            final InetSocketAddress myNodeId = aPacket.getSource();

            for (;;) {
                myLast = _lastHeartbeats.get(myNodeId);

                if (myLast == null) {
                    if (_lastHeartbeats.putIfAbsent(myNodeId,
                            new MetaDataImpl(System.currentTimeMillis(), myHeartbeat.getMetaData())) == null)
                        break;
                } else {
                    if (_lastHeartbeats.replace(myNodeId, myLast, new MetaDataImpl(System.currentTimeMillis(),
                            myHeartbeat.getMetaData())))
                    break;
                }
            }

            if ((myLast == null) && (! _stopping.get()))
                _executor.submit(
                        new Runnable() {
                            public void run() {
                                for (MembershipImpl myListener : _activeMemberships)
                                    myListener.alive(myNodeId);
                            }
                        });
        }
    }

    /**
     * Currently a simple majority test - ultimately we only need one member of the previous majority to be present
     * in this majority for Paxos to work.
     * 
     * @return true if at this point, available membership would allow for a majority
     */
    public boolean couldComplete() {
        return isMajority(_lastHeartbeats.size());
    }

    private boolean isMajority(int aSize) {
        return (aSize >= _majority);
    }

    public int getMajority() {
        return _majority;
    }

    public Map<InetSocketAddress, MetaData> getMemberMap() {
        return new HashMap<InetSocketAddress, MetaData>(_lastHeartbeats);
    }

    public Membership getMembers(MembershipListener aListener) {
        MembershipImpl myMembership = new MembershipImpl(aListener);
        _activeMemberships.add(myMembership);

        myMembership.populate(new HashSet(_lastHeartbeats.keySet()));

        return myMembership;
    }

    public InetSocketAddress getRandomMember(InetSocketAddress aLocalAddress) {
        LinkedList<InetSocketAddress> myMembers = new LinkedList<InetSocketAddress>(_lastHeartbeats.keySet());

        myMembers.remove(aLocalAddress);
        return myMembers.get(_random.nextInt(myMembers.size()));
    }

    private void sendDead(InetSocketAddress aProcess) {
        for (MembershipImpl myListener : _activeMemberships)
            myListener.dead(aProcess);
    }

    /**
     * A snapshot of the membership at some point in time, updated by the <code>FailureDetectorImpl</code> over time.  Note the snapshot only
     * reduces in size, it cannot grow so as to allow correct behaviour in cases where majorities are required.
     *
     * @author dan
     */
    class MembershipImpl implements Membership {
        /**
         * Tracks the membership that forms the base for each round
         */
        private final Set<InetSocketAddress> _initialMemberAddresses = new HashSet<InetSocketAddress>();

        /**
         * Tracks the members that have yet to respond in a round
         */
        private Set<InetSocketAddress> _outstandingMemberAddresses;

        private boolean _populated = false;
        private final MembershipListener _listener;

        private int _expectedResponses;
        private int _receivedResponses;

        private boolean _disposed = false;

        MembershipImpl(MembershipListener aListener) {
            _listener = aListener;
        }

        public boolean startInteraction() {
            synchronized(this) {
                if (!abort()) {
                    _receivedResponses = 0;
                    _expectedResponses = _initialMemberAddresses.size();
                    _outstandingMemberAddresses = new HashSet(_initialMemberAddresses);
                    return true;
                } else {
                    return false;
                }
            }
        }

        public boolean receivedResponse(InetSocketAddress anAddress) {
            synchronized(this) {
                if (_outstandingMemberAddresses.remove(anAddress)) {
                    ++_receivedResponses;
                    interactionComplete();
                    return true;
                } else {
                    _logger.warn("Not an expected response: " + anAddress);
                    return false;
                }
            }
        }

        public void alive(InetSocketAddress aProcess) {
            // Not interested in new arrivals
        }

        public void dead(InetSocketAddress aProcess) {
            _logger.warn("Death detected: " + aProcess);

            synchronized(this) {
                // Delay messages until we've got a member set
                while (! _populated) {
                    try {
                        wait();
                    } catch (InterruptedException anIE) {
                    }
                }

                _outstandingMemberAddresses.remove(aProcess);
                _initialMemberAddresses.remove(aProcess);

                // startInteraction will reset this so if we get a dead before then, it should be recorded
                //
                --_expectedResponses;

                if (abort())
                    return;

                interactionComplete();
            }
        }

        void populate(Set<InetSocketAddress> anActiveAddresses) {
            _logger.debug("Populating membership");

            synchronized(this) {
                _logger.debug("Populating membership - got lock");

                _initialMemberAddresses.addAll(anActiveAddresses);

                _logger.debug("Populating membership - addresses added");

                _populated = true;

                // Now we have a member set, accept updates
                notifyAll();
            }
        }

        public int getSize() {
            synchronized(this) {
                return _initialMemberAddresses.size();
            }
        }

        public void dispose() {
            _logger.debug("Membership disposed");

            _activeMemberships.remove(this);

            synchronized(this) {
                _disposed = true;
            }
        }

        private boolean interactionComplete() {
            if ((_receivedResponses == _expectedResponses) || (_receivedResponses >= getMajority())) {
                _listener.allReceived();
                return true;
            }

            return false;
        }

        private boolean abort() {
            if (_initialMemberAddresses.size() < getMajority()) {
                _listener.abort();
                return true;
            }

            return false;
        }

        protected void finalize() throws Throwable {
            synchronized(this) {
                if (_disposed)
                    return;
            }

            System.err.println("Membership was not disposed");
            System.err.flush();
        }
    }    
}
